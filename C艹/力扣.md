#### 1.两数之和

题目:

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

 

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

```C++
class Solution {

public:

  vector<int> twoSum(vector<int>& nums, int target) {

 unordered_map<int, int> m; //定义存放容器中的数字及位置    

 for(int i = 0; i < nums.size(); i++)//遍历整数数组

 {

   if(m.find(target-nums[i]) != m.end())   return {m[target-nums[i]], i};     

   m[nums[i]] = i;    

 }

 return {};

  }

};
```

解题思路:

当我们调用`twoSum`函数，传入数组`[3, 2, 4]`和目标值`6`时，程序的运算过程如下：

1. 初始化一个空的`unordered_map`容器，用于存放数字及其在数组中的位置。
2. 遍历数组`[3, 2, 4]`，对于每个数字，进行以下操作：
     a. 检查`unordered_map`中是否存在目标值`6`减去当前数字的结果。
     b. 如果存在，说明找到了两个数字的和为目标值的两个数，返回它们在数组中的位置。
     c. 如果不存在，将当前数字及其在数组中的位置存入`unordered_map`。
3. 如果循环结束后，仍未找到两个数字的和为目标值，返回一个空数组。
   内存中的变化如下：
   \- 初始时，`unordered_map`为空。
   \- 遍历数组过程中，`unordered_map`中的元素逐渐增多，直到找到目标值的两个数字。
   \- 如果没有找到，最后`unordered_map`中的元素数量保持不变，为一个空数组。

```c++
m.find(target-nums[i]) != m.end()
```

这行代码的意思是在`unordered_map`容器（简称`m`）中查找键为`target - nums[i]`的元素。`m.find()`函数用于在容器中查找指定的键，如果找到，则返回对应的值（这里是数字在数组中的位置）；如果没有找到，则返回`m.end()`。
在这个特定场景中：
\- `target`是一个整数，表示我们要找的两个数字的和。 
\- `nums[i]`是数组中的一个数字。
`m.find(target - nums[i])`查找的是`unordered_map`中是否存在键为`target - nums[i]`的元素。这里的键是一个计算出来的差值，表示目标值与当前数字的差。
\- 如果找到了键为`target - nums[i]`的元素，说明找到了目标值的两个数字，可以直接返回这两个位置（`m[target - nums[i]]`和`i`）； 
\- 如果没有找到，说明当前数字不是我们要找的两个数字之一，继续遍历数组。
这个操作的关键在于快速找到目标值的两个数字，而`m.find()`函数在`unordered_map`中查找元素的时间复杂度为 O(1)，非常高效。如果在遍历过程中找到了目标值的两个数字，就可以提前结束遍历，否则继续遍历直到数组遍历完毕。

在本例中，当我们遍历到数字`4`时，`unordered_map`中的内容变为：`{2: 1, 4: 2}`。这时，我们找到了两个数字`2`和`4`，它们的位置分别为 1 和 2，所以返回`{1, 2}`作为最终结果

 `return`语句用于返回一个值给调用者。在这个例子中，`twoSum`函数的返回语句如下：

```c++
return {m[target-nums[i]], i}; 
```

这意味着当函数找到两个数字的和为目标值时，它会返回一个包含这两个位置的 vector 对象。具体来说，这个 vector 对象的两个元素分别是：

1. `m[target - nums[i]]`：这是目标值减去当前数字的结果所对应的位置。 

2.  `i`：这是当前数字在数组中的位置。

   如果函数没有找到两个数字的和为目标值，那么返回一个空数组（`{}`）。这就是程序在找不到合适数字时返回的空数组。在这种情况下，调用者知道没有找到匹配的数字，可以采取其他措施，例如提示用户输入数据有误或调整算法等。

#### 2.两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

 

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

```c++
class Solution {

public:

  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {   

 ListNode *newList = l1, *pre ;  //newList指向返回的链表，pre记录保存链表的当前指针的的前一个位置。

 int flag = 0;  //进位标志

 while (l1||l2)

 {

   int value;  //两个链表的每一位相加的和

   (l1) ? (pre = l1,l1 = l1->next, value = pre->val + flag) : (pre->next=l2, pre = l2, value= flag);//

   (l2) ? (value += l2->val, l2 = l2->next) : (pre->next=l1);

   pre->val = value % 10;//将得到的数一位储存

   (value > 9) ? (flag = 1) : (flag = 0);//判断进位

 }

 if (l1 == NULL && l2 == NULL && flag == 1)//若flag多余创建新节点

   pre->next = new ListNode(1);

 return newList;

    

  }

};
```

解题方法:

此题方案是添加两个链表数值的典型解决方案之一。使用一个临时指针“此题为pre”来记录合并后的链表中的上一个节点，以及一个变量“flag”来存储上一步的进位值。算法通过遍历两个输入链表，将节点的值相加，并在需要时将进位值加到当前节点值上。当两个链表都遍历完毕后，如果还存在进位值，则在最后一个节点后添加一个值为 1 的新节点。最后，返回新创建的链表的头节点。
该解决方案的时间复杂度为 O(max(n, m))，其中 n 和 m 分别为两个链表的长度。空间复杂度为 O(1)，因为只使用常数个额外空间来存储临时变量。

```C++
(l1) ? (pre = l1,l1 = l1->next, value = pre->val + flag) : (pre->next=l2, pre = l2, value= flag);
(l2) ? (value += l2->val, l2 = l2->next) : (pre->next=l1);
```

 这段代码是用于实现一个双向链表的合并操作，其中包含两个链表（l1 和 l2），以及一个指向双向链表头节点的指针（pre）。代码的目的是将两个链表合并为一个有序的双向链表。
代码分为两部分，第一部分处理链表 l1，第二部分处理链表 l2。
第一部分（l1）：

1. **初始化 pre 为 l1，将 l1 指向下一个节点，计算 value 为 pre 的值加上标志位 flag。**
2. **如果 l1 存在下一个节点，则将 pre 指向下一个节点，并将 value 更新为 pre 的值加上 l1 的下一个节点的值。**
3. **否则，将 pre 的下一个节点指向 l2，并将 pre 更新为 l2。**

第二部分（l2）：

​	1.**初始化 pre 为 l2，将 l2 指向下一个节点。**

​	2.**如果 l2 存在下一个节点，则将 value 更新为当前值加上 l2 的下一个节点的值，并将 l2 指向下一个节点。**

​	3.**否则，将 pre 的下一个节点指向 l1。**

而后应该很好理解

#### 3.无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

 

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

 

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

![p3](./images/p3.png)

这里不要理解为右移一位,我也是想了好久

```c++
class Solution {

public:

  int lengthOfLongestSubstring(string s) {

 //创建桶(数组)，设定128个元素对应0-127ASCII码值，全部赋0

 vector<int> m(128, 0);

 //存最大长度

 int maxlen = 0;

 int head = 0;

 //遍历字符串 

 for (int i = 0; i < s.size(); i++) {

   //修改最左边的字母序号head

   head = max(head, m[s[i]]);

   //当前字母对应的ASCII码桶里存下一个位置(i+1)，用于更新head

   m[s[i]] = i + 1;

   //更新长度

   maxlen = max(maxlen, i - head + 1);

 }

 return maxlen;

  }

};
```

解题思路:

1. 首先，创建一个大小为128的vector（数组），初始化所有元素为0。这个数组用于存储每个字符在字符串中最后一次出现的索引。
2. 初始化两个变量：`maxlen` 用于存储最大子串长度，初始值为0；`head` 表示窗口最左边的字母序号，初始值为0。
3.  遍历字符串 `s`：
     a. 对于每个字符 `s[i]`，找到其在数组 `m` 中对应的索引值（即最后一次出现的位置）。如果该索引值大于 `head`，说明这个字符重复出现了，需要更新 `head`。
     b. 将当前字符的索引值（`i + 1`）添加到数组 `m` 中对应的位置。
     c. 更新最大子串长度 `maxlen`，使其等于当前窗口（`i - head + 1`）的长度。
4.  在遍历完字符串 `s` 之后，返回最大子串长度 `maxlen`。
   这个算法的时间复杂度为O(n)，其中n为字符串长度。在最坏情况下，当遍历到字符串的每个字符时，都需要查找哈希表

```c++
 head = max(head, m[s[i]]);
```

假设当前窗口中最左边的字母是a，它在桶里的位置是m[s[i]]（mi表示字母a的下一个位置），即上一个a的出现位置。当第二个a出现时，我们需要找到窗口中第一个a的位置，即head。
如果第二个a出现时，桶里存储的m[s[i]]大于等于head，说明上一个a在窗口的右侧，此时head更新为m[s[i]]，即a的出现位置。
如果第二个a出现时，桶里存储的m[s[i]]小于head，说明上一个a在窗口的左侧，此时head保持不变。

